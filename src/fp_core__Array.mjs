// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function reduce(arr, init, f) {
  return arr.reduce(f, init);
}

function reduceWithIndex(arr, init, f) {
  return arr.reduce(f, init);
}

function reduceRight(arr, init, f) {
  return arr.reduceRight(f, init);
}

function reduceRightWithIndex(arr, init, f) {
  return arr.reduceRight(f, init);
}

function findIndex(arr, fn) {
  var idx = arr.findIndex(fn);
  if (idx < 0) {
    return ;
  } else {
    return idx;
  }
}

function last(arr) {
  var index = arr.length - 1 | 0;
  return arr[index];
}

function append(arr, t) {
  return arr.concat([t]);
}

function prepend(arr, t) {
  return [t].concat(arr);
}

function flatten(arr) {
  return arr.reduce((function (t1, t2) {
                return t1.concat(t2);
              }), []);
}

function slice(arr, start, end) {
  var len = arr.length;
  if (len >= end && start < end && start < len) {
    return arr.slice(start, end);
  }
  
}

function head(arr) {
  return arr[0];
}

function tail(arr) {
  var len = arr.length;
  return slice(arr, 1, len);
}

function isEmpty(arr) {
  var match = arr[0];
  return match === undefined;
}

function deleteAt(arr, i) {
  var head = i === 0 ? slice(arr, -1, 0) : slice(arr, 0, i);
  var tail = slice(arr, i + 1 | 0, arr.length);
  if (head !== undefined && tail !== undefined) {
    return head.concat(tail);
  }
  
}

function insertAt(arr, i, item) {
  var len = arr.length;
  var head = i === 0 ? slice(arr, -1, 0) : slice(arr, 0, i);
  var tail = slice(arr, i, len);
  if (head !== undefined && tail !== undefined) {
    return head.concat([item]).concat(tail);
  }
  if (len !== 0) {
    return ;
  } else {
    return [item];
  }
}

function modifyAt(arr, i, updateFn) {
  var len = arr.length;
  var item = Belt_Array.get(arr, i);
  var head = i === 0 ? slice(arr, -1, 0) : slice(arr, 0, i);
  var tail = slice(arr, i + 1 | 0, len);
  if (head !== undefined && tail !== undefined && item !== undefined) {
    return head.concat([Curry._1(updateFn, Caml_option.valFromOption(item))]).concat(tail);
  }
  
}

function updateAt(arr, i, item) {
  var len = arr.length;
  var head = i === 0 ? slice(arr, -1, 0) : slice(arr, 0, i);
  var tail = slice(arr, i + 1 | 0, len);
  if (head !== undefined && tail !== undefined) {
    return head.concat([item]).concat(tail);
  }
  
}

function forEach(prim0, prim1) {
  prim0.forEach(prim1);
}

export {
  append ,
  deleteAt ,
  findIndex ,
  flatten ,
  forEach ,
  head ,
  insertAt ,
  isEmpty ,
  last ,
  modifyAt ,
  reduce ,
  reduceWithIndex ,
  reduceRight ,
  reduceRightWithIndex ,
  slice ,
  tail ,
  prepend ,
  updateAt ,
}
/* No side effect */
